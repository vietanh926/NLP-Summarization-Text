








Tìm kiếm đường đi ngắn nhất trên đồ thị (Bellman-Ford) | How Kteam






































































 Đăng ký
            

 Đăng nhập
            









PG
Pages



Khóa học





Lập trình





                                Lập trình C# .Net
                            



                                Lập trình C++
                            



                                Lập trình Android
                            



                                Điều trường học không dạy
                            



                                Thủ thuật lập trình
                            



                                Lập trình Java
                            



                                Unity3D
                            



                                Phân tích thiết kế
                            



                                Lập trình Python
                            



                                Lập trình PHP
                            



                                JavaScript - (Website)
                            



                                Lập trình Front-End
                            



                                Lập trình Mobile
                            





Microsoft Office 2016





                                Microsoft Word 2016
                            



                                Microsoft Excel 2016
                            



                                Microsoft PowerPoint 2016
                            





IT & Phần mềm





                                Thủ thuật máy tính
                            



                                Hướng dẫn cài đặt
                            



                                Bảo mật máy tính
                            



                                Phần cứng & Bảo mật
                            





Đồ họa hình ảnh





                                Adobe Photoshop LightRoom
                            





Kinh tế





                                Quản trị kinh doanh
                            



                                Kế toán
                            



                                Nhân sự
                            



                                SEO
                            



                                Marketing
                            





Ngoại ngữ





                                Tiếng anh
                            





Kỹ năng mềm





                                Kỹ năng mềm
                            





Tin tức





                                Tin tức công nghệ
                            






Khóa học



Hỏi đáp


Bài viết


Tag


Kter


Về Kteam


Tài trợ


Phản hồi
































































































































































 Đặt câu hỏi
                            

 Viết bài
                            

 Tạo series
                            






Tài khoản




 Đăng nhập
            

 Đăng ký
            









 














 











Tìm kiếm đường đi ngắn nhất trên đồ thị (Bellman-Ford)
Cấu trúc dữ liệu và giải thuật









 0.0 (0 đánh giá)
                    



                        Tạo bởi Katsu


                        Cập nhật lần cuối 17:49 07-07-2022


10.087 lượt xem
                    

1 bình luận
                    


Tác giả/Dịch giả:


huulam3011



K9



                    Học nhanh
                    









































Khóa học
Lập trình
Lập trình C++
Cấu trúc dữ liệu và giải thuật
Tìm kiếm đường đi ngắn nhất trên đồ thị (Bellman-Ford)

















                        Danh sách bài học
                    
























Tìm kiếm đường đi ngắn nhất trên đồ thị (Bellman-Ford)


Cấu trúc dữ liệu và giải thuật


                        Tạo bởi Katsu


10.087


1





                    Học nhanh
                    








                            Tìm kiếm đường đi ngắn nhất trên đồ thị (Bellman-Ford)
                        












                                        Nội dung bài viết
                                        
                                            Học nhanh
                                            








Bài trước


Bài sau










Dẫn nhập
Trong bài học trước, chúng ta đã cùng nhau đi tìm hiểu về thuật toán Floyd-Warshall trong tìm kiếm đường đi ngắn nhất trên đồ thị. Hôm nay, chúng ta sẽ cùng nhau đi tìm hiểu về một thuật toán có thể coi là thuật toán phổ biến nhất
 trong tìm kiếm đường đi ngắn nhất. Để biết cụ thể, hãy cùng nhau bắt đầu bài học nào!

Nội dung
Để có thể tiếp thu bài học này một cách tốt nhất, các bạn nên có những kiến thức cơ bản về:

Các kiến thức cần thiết để theo dõi khóa học
Đồ thị và cây
BFS và DFS
Priority Queue
Thuật toán Floyd-Warshall
Thuật toán Dijkstra 

Trong bài học ngày hôm nay, chúng ta sẽ cùng nhau tìm hiểu về:

Chu trình âm 

Thuật toán Bellman-Ford 

Chu trình âm
Khái niệm
Ta có một đồ thị như sau:

Bài toán đặt ra ở đây là tìm đường đi ngắn nhất từ đỉnh 1 đến các đỉnh còn lại.
Nhìn vào đồ thị trên, ta thấy có một điểm khác hơn so với các đồ thị ở những bài học trước đó là cạnh nối đỉnh 4 và đỉnh 5 có trọng số là một số âm. Vậy thì điều này ảnh hưởng gì đến bài toán?

Hãy cùng thử sử dụng thuật toán Dijkstra lên đồ thị trên nhé:

Đầu tiên, dist = [0, ∞, ∞, ∞, ∞, ∞] và
mark = [0, 0, 0, 0, 0, 0] (ta coi 0 là false và 1 là true).
Ta chọn u = 1 do 
dist[1] = 0 nhỏ nhất và thoả mãn mark[1] = 0. Xét các đỉnh
v có cạnh nối trực tiếp từ đỉnh 1.

Xét v = 2, ta thấy 
dist[1] + độ dài cạnh (1, 2) = 3 < dist[2] = ∞ nên dist[2] = 3





Do không còn đỉnh nối từ đỉnh 1 nên ta kết thúc xét đỉnh 1 và đánh dấu
mark[1] = 1 


Khi này, dist = [0, 3, ∞, ∞, ∞, ∞] và
mark = [1, 0, 0, 0, 0, 0] Ta chọn u = 2 do 
dist[2] = 3 nhỏ nhất và thoả mãn mark[2] = 0. Xét các đỉnh
v có cạnh nối trực tiếp từ đỉnh 2.

Xét v = 3, ta thấy 
dist[2] + độ dài cạnh (2, 3) = 8 < dist[3] = ∞ nên dist[3] = 8
Do không còn đỉnh nối từ đỉnh 2 nên ta kết thúc xét đỉnh 2 và đánh dấu
mark[2] = 1 
Khi này, dist = [0, 3, 8, ∞, ∞, ∞] và
mark = [1, 1, 0, 0, 0, 0] Ta chọn u = 3 do 
dist[3] = 8 nhỏ nhất và thoả mãn mark[3] = 0. Xét các đỉnh
v có cạnh nối trực tiếp từ đỉnh 3.

Xét v = 4, ta thấy 
dist[3] + độ dài cạnh (3, 4) = 11 < dist[4] = ∞ nên dist[4] = 8
Do không còn đỉnh nối từ đỉnh 3 nên ta kết thúc xét đỉnh 3 và đánh dấu
mark[3] = 1 
Khi này, dist = [0, 3, 8, 11, ∞, ∞] và
mark = [1, 1, 1, 0, 0, 0] Ta chọn u = 4 do 
dist[4] = 11 nhỏ nhất và thoả mãn mark[4] = 0. Xét các đỉnh
v có cạnh nối trực tiếp từ đỉnh 4.

Xét v = 5, ta thấy 
dist[4] + độ dài cạnh (4, 5) = 3 < dist[5] = ∞ nên dist[5] = 3
Do không còn đỉnh nối từ đỉnh 4 nên ta kết thúc xét đỉnh 4 và đánh dấu
mark[4] = 1 
Khi này, dist = [0, 3, 8, 11, 3, ∞] và
mark = [1, 1, 1, 1, 0, 0] Ta chọn u = 5 do 
dist[5] = 3 nhỏ nhất và thoả mãn mark[5] = 0. Xét các đỉnh
v có cạnh nối trực tiếp từ đỉnh 5.

Xét v = 3, ta thấy 
dist[45] + độ dài cạnh (4, 3) = 7 < dist[3] = 8 

Đây chính là lúc mà điều bất thường xuất hiện. Trong lập luận đã nêu ở bài trước, chúng ta biết rằng một đỉnh khi được đánh dấu là đã xét xong thì đường đi từ đỉnh nguồn đến đỉnh đó phải là đường đi ngắn nhất. Tuy nhiên, ta thấy
 ở trong ví dụ trên, khi một đỉnh được đánh dấu là đã xét thì vẫn tồn tại đường đi khác ngắn hơn. Vậy thì
lý do là tại sao?
Ta thấy rằng, đường đi  có tổng trọng số là
, là một số âm. Như đã biết, mọi số nguyên khi cộng với số âm thì đều cho ra kết quả nhỏ hơn nó. Do đó, chỉ cần ta đi qua đường đi trên vô hạn lần thì độ dài đường
 đi sẽ giảm vô hạn lần. Lúc này, không tồn tại đường đi ngắn nhất từ đỉnh 1 đến các đỉnh 3, đỉnh 4 và đỉnh 5. Đường đi
 được gọi làm một
chu trình âm.
Chu trình âm là một chu trình mà tổng trọng số các cạnh thuộc chu trình đó là số âm. Khi xuất hiện chu trình âm thì sẽ không tồn tại đường đi ngắn nhất giữa một số cặp đỉnh.

Ý tưởng
Vậy thì làm sao để thoát ra khỏi “hố đen” chu trình âm? Thực ra ý tưởng khá đơn giản. Ta thấy với một đơn đồ thị, nếu có
 đỉnh thì sẽ tồn tại tối đa
 cạnh nối đến một đỉnh. Do đó, nếu không tồn tại chu trình âm, một đỉnh sẽ chỉ được cập nhật tối đa
 lần. Do đó ta chỉ cần kiểm tra nếu một đỉnh bị cập nhật
 lần có nghĩa là tồn tại chu trình âm và không có đường đi ngắn nhất giữa đỉnh nguồn và đỉnh đó.


Thuật toán Bellman-Ford
Bài toán đặt ra
Cho một đồ thị có hướng gồm  đỉnh (đánh số từ 1 đến
),
 cạnh có hướng và có trọng số là số nguyên,
có thể âm hoặc dương. Cho một đỉnh , hãy tìm độ dài đường đi ngắn nhất từ đỉnh
 đến tất cả các đỉnh còn lại.

Nếu như không tồn tại đường đi giữa hai đỉnh, in ra -1.
Nếu như không tồn tại đường đi ngắn nhất giữa hai đỉnh, in ra -2.
Input:

Dòng : Gồm 3 số nguyên
 lần lượt thể hiện cho số đỉnh của đồ thị, số cạnh của đồ thị và đỉnh yêu cầu

Dòng : Mỗi dòng gồm 3 số nguyên
 thể hiện một cạnh có hướng nối từ đỉnh
 đến đỉnh
 và có trọng số
w 

Output:

Gồm  dòng, dòng thứ
 thể hiện độ dài đường đi ngắn nhất từ đỉnh
 đến đỉnh 

Ví dụ:



Input
Output



6 6 1
1 2 3
2 3 5
3 4 3
4 5 -8
5 3 4
6 5 2


0
3
-2
-2
-2
-1





Giải thích ví dụ:

Đây chính là đồ thị ở ví dụ phía trên.

Ý tưởng
Ý tưởng của thuật toán Bellman-Ford như sau: 

Ta sẽ xét lần lượt tất cả cách cạnh của đồ thị. Với mỗi cạnh nối từ đỉnh
 đến đỉnh
, ta sẽ xem thử cập nhật đường đi ngắn nhất từ đỉnh nguồn đến đỉnh
 thông qua đường đi từ
 đến
. Do ta đã nhận xét ở trên một đỉnh chỉ cập nhật tối đa
 lần nên tại lần cập nhật thứ
, nếu như vẫn có đỉnh được cập nhật nghĩa là đỉnh đó thuộc chu trình âm.

Cách cài đặt
Về cơ bản thì thuật toán Bellman-Ford khá dễ cài đặt, chỉ có một điểm khác đó là ta sẽ dùng một cấu trúc để lưu trữ các cạnh với 3 thông tin gồm hai đỉnh và trọng số của cạnh đó. Chi tiết các bạn hãy quan sát phần code phía bên
 dưới.
Code

#include<bits/stdc++.h>
using namespace std;

typedef long long ll;

const int MaxN = 1 + 1e2;
const ll INF = 1e18;

int n, m, s, mark[MaxN];
ll dist[MaxN];

class Edge{
    public:
        int u, v, weight;

        Edge(int _u, int _v, int _weight): u(_u), v(_v), weight(_weight){}
};

vector<Edge> edges;

void Bellman_Ford(){
    fill(dist + 1, dist + n + 1, INF);
    dist[s] = 0;

    for(int i = 1; i <= n; i++){
        for(Edge e : edges){
            if(dist[e.u] + e.weight < dist[e.v]){
                // Tại lần cập nhật thứ n, nếu đỉnh vẫn được cập nhật nghĩa là nó thuộc chu trình âm và ta đánh dấu nó 
                if(i == n) mark[e.v] = 1;
                dist[e.v] = dist[e.u] + e.weight;
            }
        }
    }
}

int main(){
    freopen("CTDL.inp","r",stdin);
    freopen("CTDL.out","w",stdout);
    cin >> n >> m >> s;
    for(int i = 1; i <= m; i++){
        int u, v, weight;
        cin >> u >> v >> weight;
        edges.push_back(Edge(u, v, weight));
    }
    Bellman_Ford();
    for(int i = 1; i <= n; i++)
    if(!mark[i]){ 
        if(dist[i] == INF) cout << "-1" << endl;
        else cout << dist[i] << endl;
    } else cout << "-2" << endl;

    return 0;
}


Độ phức tạp
Nhìn vào đoạn code trên, ta thấy có một vòng lặp duyệt qua tất cả các cạnh được lặp lại
 lần. Do đó, độ phức tạp thuật toán là
.

So sánh các thuật toán




Thuật toán Floyd
Thuật toán Dijikstra
Thuật toán Bellman-Ford


Mục đích
Tìm đường đi ngắn nhất giữa mọi cặp đỉnh
Tìm đường đi ngắn nhất từ đỉnh nguồn đến các đỉnh còn lại
Tìm đường đi ngắn nhất từ đỉnh nguồn đến các đỉnh còn lại


Thời gian code
Nhanh
Lâu
Nhanh


Tìm được chu trình âm
Không
Không
Có


Độ phức tập thời gian







Kết luận
Qua bài này chúng ta đã nắm về Tìm kiếm đường đi ngắn nhất trên đồ thị
với thuật toán Bellman-Ford
Bài sau chúng ta sẽ tìm hiểu về Loang
Cảm ơn các bạn đã theo dõi bài viết. Hãy để lại bình luận hoặc góp ý của mình để phát triển bài viết tốt hơn. Đừng quên “Luyện tập – Thử thách – Không ngại khó”.


Tải xuống

Tài liệu
Nhằm phục vụ mục đích học tập Offline của cộng đồng, Kteam hỗ trợ tính năng lưu trữ nội dung bài học Tìm kiếm đường đi ngắn nhất trên đồ thị (Bellman-Ford) dưới dạng file PDF trong link bên dưới.
Ngoài ra, bạn cũng có thể tìm thấy các tài liệu được đóng góp từ cộng đồng ở mục TÀI LIỆU trên thư viện Howkteam.com

Đừng quên like và share để ủng hộ Kteam và tác giả nhé!





Thảo luận
Nếu bạn có bất kỳ khó khăn hay thắc mắc gì về khóa học, đừng ngần ngại đặt câu hỏi trong phần BÌNH LUẬN bên dưới hoặc trong mục HỎI & ĐÁP trên thư viện Howkteam.com để nhận được sự hỗ trợ từ cộng đồng.



CỘNG ĐỒNG HỎI ĐÁP HOWKTEAM.COM





GROUP THẢO LUẬN FACEBOOK











                                        Nội dung bài viết
                                    













Tác giả/Dịch giả








huulam3011


Mình là Nguyễn Hữu Lâm, một người có niềm đam mê rất lớn đối với lập trình. Hiện tại, mình đang là sinh viên Khoa học máy tính của Đại học Bách Khoa Hà Nội. Mong muốn của mình là có thể chia sẻ những kiến thức mà bản thân có cho mọi người, học hỏi, kết bạn
 với tất cả những người có cùng đam mê với mình.










K9


Nhà sáng lập Howkteam.com, KQuiz.vn & tác giả các khóa học C#, Auto, Unity3D, Python....
Với mong muốn mang đến kiến thức chất lượng, miễn phí cho mọi người, với tâm huyết phá bỏ rào cản kiến thức từ việc giáo dục thu phí. Tôi đã cùng đội ngũ Kteam đã lập nên trang website này để thế giới phẳng hơn.
Hãy cùng chúng tôi lan tỏa kiến thức đến cộng đồng! 









Khóa học



Cấu trúc dữ liệu và giải thuật


Bạn đã từng đau đầu với các cấu trúc stack, queue,.. hoặc cảm thấy cực kỳ khó khăn với các thuật toán sắp xếp, tìm kiếm được sử dụng trong lập trình. Đừng lo lắng! Trong khoá học này, chúng ta sẽ cùng nhau tìm hiểu một cách đơn giản nhất về cấu
 trúc dữ liệu và giải thuật, cũng như giúp bạn nắm rõ hơn về các kiến thức này.
Hãy cùng xem cấu trúc dữ liệu và giải thuật có gì đáng sợ không nhé!







Đánh giá














Bình luận








Để bình luận, bạn cần đăng nhập bằng tài khoản Howkteam.
Đăng nhập
















tboros
đã bình luận
08:34 28-07-2023


Diijska O(Mlogn) là trên đồ thị thưa thôi đk ạ , còn trên đồ thị bình thường thì O(N^2 + M)




0
0

Trả lời

 Báo cáo
                        























 Danh sách bài giảng




 Nội dung





 Không có video.




 Danh sách bài giảng










Đánh giá và Nhận xét

































Thông tin Kteam

Về Kteam
Dịch vụ
Liên hệ

Đóng góp từ cộng đồng

Tài trợ
Người ủng hộ



Lĩnh vực



Khoá học



Cộng đồng

Hỏi đáp
Tài liệu
Chiến dịch

Liên kết

Vted - Học toán online chất lượng cao
Lập trình VB.NET
Linux Team Việt Nam



Kết nối với Kteam
Kết nối với Kteam qua mạng xã hội




Chứng nhận








Howkteam © 2024
















Quan tâm

















 Tag theo dõi
                        












































Yêu cầu đăng nhập








Để sử dụng tính năng này, Bạn cần đăng nhập bằng tài khoản Howkteam.
Đăng nhập









AD BLOCKER DETECTED

            Để xem được nội dung và giúp Kteam duy trì hoạt động. 
Bạn vui lòng tắt Adblock trên website howkteam.vn nhé!



















































